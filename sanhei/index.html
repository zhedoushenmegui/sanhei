<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>还是三合一呀</title>
    <!-- 其他 meta 标签保持不变 -->

    <!-- 引入样式 -->
    <link rel="stylesheet"
          href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/5.0.0/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="http://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap-theme.min.css"/>
    <link rel="stylesheet" href="http://www.bootcss.com/p/buttons/css/buttons.css"/>
    <link rel="stylesheet" href="./index.css"/>

    <!-- 引入 Vue 3 -->
    <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
    <!-- 引入其他依赖 -->
    <script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap/5.0.0/js/bootstrap.min.js"></script>
    <script src="../javascript/util.js"></script>

</head>
<body>
<div id="app">
    <div id="content" class="col-xs-12 col-sm-12 col-md-6 col-lg-4 col-md-offset-3 col-lg-offset-4">
        <div id="head">
            <div style="display: flex; justify-content: space-evenly; align-items: center">
                <div>
            <span class="pot" :class="'cl' + now" style="width: 40px; height: 40px">
              <span class="pot-val">{{ now }}</span>
            </span>
                </div>
                <button
                        class="btn button dim button-border button-rounded button-primary"
                        @click="changeDim(2)">
                    重新开始
                </button>
            </div>
        </div>

        <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12 panel" id="scorePanel">
            <p class="score-panel">
                <span class="col-xs-4 col-sm-4 col-md-4 col-lg-4">得分:{{ score }}</span>
                <span class="col-xs-4 col-sm-4 col-md-4 col-lg-4">步数:{{ step }}</span>
            </p>
        </div>

        <div id="playground">
            <div id="tbody">
                <div class="line" v-for="(line, rowIndex) in sandbox" :key="rowIndex">
            <span
                    class="pot"
                    :class="'cl' + pot.val"
                    v-for="(pot, potIndex) in line"
                    :key="potIndex"
                    @click="onPut(pot)">
              <span class="pot-val">{{ pot.val }}</span>
            </span>
                </div>
            </div>
        </div>

        <!-- temp hub -->
        <div v-if="tempHub.length > 0" class="col-xs-12 col-sm-12 col-md-12 col-lg-12 panel temp-hub">
            <div>
                <div
                        v-for="(item, index) in tempHub"
                        :key="index"
                        class="pot"
                        :class="'cl' + item"
                        @click="swapTempHub(index)">
                    <span class="pot-val">{{ item }}</span>
                </div>
            </div>
        </div>

        <!-- best score -->
        <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12 panel">
            <p class="score-panel">个人最好成绩</p>
            <p class="score-panel">
                <span class="col-xs-4 col-sm-4 col-md-4 col-lg-4">得分:{{ best.score }}</span>
                <span class="col-xs-4 col-sm-4 col-md-4 col-lg-4">步数:{{ best.step }}</span>
                <span class="col-xs-4 col-sm-4 col-md-4 col-lg-4">数字:{{ best.number }}</span>
            </p>
        </div>

        <!-- 其他链接 -->
        <div style="font-size: x-large; padding: 20px; background-color: white">
            <div><a href="/color_tube.html">color tube</a></div>
            <div><a href="/fake_handou.html">fake handou</a></div>
            <div><a href="/wencai.html">wencai</a></div>
            <div><a href="/flight.html">flight</a></div>
        </div>
    </div>
</div>


<!-- 添加 JavaScript 实现 -->
<script>
    // 定义常量和工具函数
    const DIM_BASE = 2;
    /// assert (DIM_BASE >= 2);
    const EXC = 402;
    //
    const lsNameArray = {
        map: 'map',
        best: 'best'
    };

    // 配置对象
    const config = {
        prob: {
            1: 800,
            2: 200,
            3: 50,
            4: 13,
            5: 3,
            '-1': 81,
            '-2': 9,
            '-3': 3,
            [EXC]: 3,  /// 道具 移除地图上一个元素
        },
        defaultDim: 2,
        gameStatus: {
            'ready': 0,
            'running': 1,
            'end': 2,
            'sys_pause': 3
        },
        upLimit: 9,          // 数字上限
        downLimit: -4,       // 数字下限
        pauseTime: 100,      // 数字落下后暂停时间
        scoreFactor: 2,     // 每多一个增加2倍分数
        scoreFactorLevel: 3,        // 每多一层增加3倍分数
        mapSize: 7,                 // 地图尺寸
        tempHubNum: 3,              // 临时存储区大小
        alertTime: 3,               // 警告提示次数
    };

    // 随机生成棋盘内容
    function generator(probs) {
        let all = 0;
        for (let i in probs) {
            all += probs[i];
        }
        let mod = Math.floor(Math.random() * all);
        for (let i in probs) {
            mod -= probs[i]
            if (mod < 0) {
                let val = parseInt(i);
                console.log(val, i )
                return val
            }
        }
        return 1;
    }

    /**
     * 坐标转换为键值
     * @param loc
     * @returns {*}
     */
    function locToKey(loc) {
        return loc.join(',');
    }

    // 创建 Vue 应用
    const app = Vue.createApp({
        data() {
            return {
                forbidLocInfoTime: config.alertTime,
                gameStatus: config.gameStatus.ready,
                map: [],  /// 最低是2维
                rangeLevel: 0,  // 临时计数器，用于追踪单次落子操作中连续合并的次数
                ////
                cols: [],
                sandbox: [],
                now: 0,
                score: 0,
                step: 0,
                tempHub: [],
                locations: [],
                ////
                best: {
                    number: 0,
                    score: 0,
                    step: 0
                },
                settings: {
                    soundPlay: true
                },
                dimBase: DIM_BASE,
                size: config.mapSize,
                dim: config.defaultDim,
            }
        },
        methods: {
            init(restart) {
                this.gameStatus = config.gameStatus.ready;
                this.score = 0;
                this.step = 0;
                this.cols = [];
                this.locations = [];
                for (let i = 0; i < this.size; i++) {
                    this.cols.push(String.fromCharCode(65 + i));
                    this.sandbox.push([])
                }
                for (let i = 0; i < this.dim; i++) {
                    this.locations.push(0);
                }
                // 暂存区初始化
                this.initTempHub();
                // 状态初始化
                if (restart || this.loadStatus() === null) {
                    // 重新生成地图
                    this.initMap(this.dim, this.size);
                    this.generateNextChess();
                } else {
                    // 从ls 里加载地图, 配置, 分数等
                    this.loadStatus();
                    if (this.map.length !== this.size) {
                        this.initMap(this.dim, this.size);
                    }
                    if (this.tempHub === undefined) {
                        this.tempHub = [];
                        // 暂存区初始化
                        this.initTempHub();
                    }
                    if (this.tempHub.length > config.tempHubNum) {
                        let arr = []
                        for (let i = 0; i < config.tempHubNum; i++) {
                            arr.push(this.tempHub[i])
                        }
                        this.tempHub = arr;
                    }
                }
                // 更新地图
                this.changePlane(this.map);
                // 地图重绘
                // setInterval(potSize, 500);
                // 保存地图状态
                this.saveStatus();
            },
            readScore() {
                if (localStorage.getItem(lsNameArray.best) === null) {
                    return;
                }
                let str = localStorage.getItem(lsNameArray.best);
                let jsonBest = base64Decoder(str);
                this.best = JSON.parse(jsonBest);
            },
            initTempHub() {
                this.tempHub = [];
                for (let i = 0; i < config.tempHubNum; i++) {
                    this.tempHub.push(0);
                }
            },
            /**
             *
             * @param level
             * @param location
             * @param dim
             * @param size
             * @returns {{val: (number|number), loc}|*[]}
             */
            generateMap(level, location, dim, size) {
                if (level === dim) {
                    let probs = deepCopy(config.prob);
                    probs[0] = probs[1] * 2;  // 空白的概率是 1 的2倍
                    probs[EXC] = 0;           // 地图上不会刷新EXC
                    let number = generator(probs);
                    this.updateBest(number);
                    return {
                        val: number,
                        loc: location
                    };
                } else {
                    let tmpMap = [];
                    for (let i = 0; i < size; i++) {
                        let tmpLoc = deepCopy(location);
                        tmpLoc.push(i);
                        tmpMap[i] = this.generateMap(level + 1, tmpLoc, dim, size)
                    }
                    return tmpMap;
                }
            },
            initMap(dim, size) {
                // 生成地图
                this.map = this.generateMap(0, [], dim, size);
                this.changePlane(this.map)
            },
            onPut(pot){
                if(this.gameStatus === config.gameStatus.end) {
                    if(!confirm("重新开始?")) {
                        return;
                    }else {
                        this.init(true);
                    }
                }
                ////
                if (this.now === EXC) {
                    if(pot.val === 0) {
                        return;
                    }
                    this.now = pot.val;
                    pot.val = 0;
                } else {
                    this.gameStatus = config.gameStatus.running;
                    if(pot.val !== 0) {
                        return;
                    }
                    this.step ++;
                    this.chessIn(pot.loc)
                    this.updateBest(pot.val)
                }
            },
            /**
             * 计算分数, 跟当前合成的元素和合成的个数有关
             * @param val
             * @param size
             */
            countScore(val, size) {
                let factor = 5 + config.scoreFactor * (size - 3) + config.scoreFactorLevel * this.rangeLevel;
                if (val === config.downLimit) {
                    // 负数合成消失的时候加分, 平时减分
                    factor *= -1;
                }
                this.score += factor * val;
            },
            /**
             * 每个棋子的进阶
             * @param target
             * @returns {*|number}
             */
            chessNextLevel(target) {
                if (target < 0) {
                    target--;
                } else {
                    target++;
                }
                if (target > config.upLimit || target < config.downLimit) {
                    return 0;
                }
                return target;
            },
            generateNextChess(){
                let probs = deepCopy(config.prob);
                this.now = generator(probs);
            },
            chessIn(location) {
                this.rangeLevel = 0
                let chessNum = deepCopy(this.now)
                // 生成
                this.generateNextChess();
                this.setTargetChess(location, chessNum)
                this.changePlane(this.map);
                ///
                this.gameStatus = config.gameStatus.sys_pause;
                let v = this;
                setTimeout(function () {
                    this.gameStatus = config.gameStatus.running;
                    if (!v.checkAlive()) {
                        v.gameStatus = config.gameStatus.end;
                        alert('游戏结束!');
                    }
                }, 100)
                ////
                while(true) {
                    let val = this.getTargetChess(location);
                    let scorePoints = this.chessInProcess(location, val);
                    let len = scorePoints.length;
                    if (len < 3) {
                        break;
                    }
                    for (let i = 0; i < len; i++) {
                        this.setTargetChess(scorePoints[i], 0);
                    }
                    // 计算分数
                    this.countScore(val, len);
                    // 计算进阶数字
                    let next = this.chessNextLevel(val);
                    this.setTargetChess(location, next);
                    this.rangeLevel++;
                    // 更新最好成绩
                    this.updateBest(next);
                }
                ///
                this.changePlane(this.map);
            },
            changePlane(map) {
                let location = this.locations;
                let tmpMap = map;
                for (let i = 0, len = location.length - DIM_BASE; i < len; i++) {
                    tmpMap = tmpMap[location[i]];
                }
                this.sandbox = tmpMap;
            },
            onChangePlane(index, ifUp){
                let t = this.locations[index];
                if (ifUp) {
                    t++;
                } else {
                    t--;
                }
                this.locations[index] = (t + config.mapSize * 10) % config.mapSize;
                this.changePlane(this.map);
            },
            chessInProcess(location, val) {
                // 周围相邻的点, 已经出现过
                let seeds = {};
                let key = locToKey(location);
                seeds[key] = location;
                // 相同的点
                let score = {};
                // 周围相邻的点, 未使用
                let unusedPoints = {};
                unusedPoints[key] = location;
                while (true) {
                    for (let name in unusedPoints) {
                        let loc = unusedPoints[name];
                        delete unusedPoints[name];
                        // 指定位置的数字与当前落子位置的数字相同
                        if (this.getTargetChess(loc) === val) {
                            let locStr = locToKey(loc);
                            score[locStr] = loc;
                            for (let i = 0; i < this.dim; i++) {
                                let a = loc[i] - 1, b = loc[i] + 1;
                                // 相邻的位置在范围内
                                if (a >= 0 && a < this.size) {
                                    let tmpLoc = deepCopy(loc);
                                    tmpLoc[i] = a;
                                    let keyStr = locToKey(tmpLoc);
                                    if (seeds[keyStr] === undefined) {
                                        seeds[keyStr] = tmpLoc;
                                        unusedPoints[keyStr] = tmpLoc;
                                    }
                                }
                                if (b >= 0 && b < this.size) {
                                    let tmpLoc = deepCopy(loc);
                                    tmpLoc[i] = b;
                                    let keyStr = locToKey(tmpLoc);
                                    if (seeds[keyStr] === undefined) {
                                        seeds[keyStr] = tmpLoc;
                                        unusedPoints[keyStr] = tmpLoc;
                                    }
                                }
                            }
                        }
                    }
                    let size = 0;
                    for (let item in unusedPoints) {
                        size++;
                    }
                    if (size < 1) {
                        break;
                    }
                }

                let scorePoints = [];
                for (let item in score) {
                    scorePoints.push(score[item]);
                }
                return scorePoints;
            },
            checkAlive() {
                this.saveStatus();
                let alive = false;
                function traversal(node) {
                    if (alive) {
                        return;
                    }
                    if (node['val'] === undefined) {
                        for (let i = 0, len = node.length; i < len; i++) {
                            traversal(node[i]);
                            if (alive) {
                                return;
                            }
                        }
                    } else {
                        if (node['val'] === 0) {
                            alive = true;
                        }
                    }
                }
                traversal(this.map);
                return alive;
            },
            setTargetChess(location, val) {
                let tmpMap = this.map;
                let len = location.length;
                for (let i = 0; i < len - DIM_BASE; i++) {
                    tmpMap = tmpMap[location[i]];
                }
                let x = location[len - 2], y = location[len - 1];
                tmpMap[x][y]['val'] = val;
            },
            getTargetChess(location) {
                let tempMap = deepCopy(this.map);
                if (location.length !== this.dim) {
                    alert('系统bug!建议刷新重试');
                }
                for (let i = 0, len = location.length; i < len; i++) {
                    tempMap = tempMap[location[i]]
                }
                return tempMap.val;
            },
            swapTempHub(index) {
                let temp = this.tempHub[index];
                this.tempHub[index] = this.now;
                if (temp === 0) {
                    // 原来暂存区是空的, 则重新生成一个棋子
                    this.generateNextChess()
                } else {
                    this.now = temp;
                }
                this.saveStatus();
            },
            changeDim(dim) {
                if (this.gameStatus === config.gameStatus.running) {
                    let ret = confirm("将重新开始, 确认?");
                    if (!ret) {
                        return;
                    }
                }
                this.dim = dim;
                this.init(true);
            },
            changeSoundState() {
                this.settings.soundPlay = !this.settings.soundPlay;
                this.saveStatus()
            },
            saveStatus() {
                let mapObj = {
                    map: this.map,
                    next: this.now,
                    score: this.score,
                    step: this.step,
                    tempHub: this.tempHub,
                    settings: this.settings,
                    forbidLocInfoTime: this.forbidLocInfoTime,
                    gameStatus: this.gameStatus,
                };
                let jsonMap = JSON.stringify(mapObj);
                let mapStr = base64Encoder(jsonMap);
                localStorage.setItem(lsNameArray.map, mapStr);
                return localStorage.getItem(lsNameArray.map) === null;
            },
            loadStatus() {
                if (localStorage.getItem(lsNameArray.map) === null) {
                    return null;
                }
                let mapStr = localStorage.getItem(lsNameArray.map);
                let jsonMap = base64Decoder(mapStr);
                let obj = JSON.parse(jsonMap);
                this.map = obj.map;
                this.now = obj.next;
                this.score = obj.score;
                this.step = obj.step;
                this.tempHub = obj.tempHub;
                this.settings = obj.settings;
                if (obj['forbidLocInfoTime'] !== undefined) {
                    this.forbidLocInfoTime = obj.forbidLocInfoTime;
                } else {
                    this.forbidLocInfoTime = 1;
                }
                if (obj['gameStatus'] !== undefined) {
                    this.gameStatus = obj.gameStatus;
                } else {
                    this.gameStatus = config.gameStatus.running;
                }
            },
            updateBest(number) {
                if (this.step > this.best.step) {
                    this.best.step = this.step;
                }
                if (this.score > this.best.score) {
                    this.best.score = this.score;
                }
                if (number > this.best.number) {
                    this.best.number = number;
                }
                let jsonBest = JSON.stringify(this.best);
                let strBest = base64Encoder(jsonBest);
                localStorage.setItem(lsNameArray.best, strBest);
            },
        },
        mounted() {
            this.readScore();

            this.init(false);
        }
    });

    // 挂载应用
    app.mount('#app');
</script>
</body>
</html>
4